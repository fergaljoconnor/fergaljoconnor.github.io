<!DOCTYPE html>
<html  dir="ltr" lang="en" data-theme="light"><head>
    <title> Fergal O&#39;Connor | Zero_v - Cutting Out VTable Calls with the Rust Type System </title>

    
    <meta charset="utf-8"><meta name="generator" content="Hugo 0.83.1" /><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
    <meta name="description" content="Data Engineer. Rust Enthusiast.
Perpetual Tinkerer.">
    
    
    
    
    <link rel="stylesheet"
        href="/css/main.min.69a557b4fc895e1566037155c2b37c752bb8ccf82803bf8551c60ae44f0f4e23.css"
        integrity="sha256-aaVXtPyJXhVmA3FVwrN8dSu4zPgoA7&#43;FUcYK5E8PTiM="
        crossorigin="anonymous"
        type="text/css">
    
    
    <link rel="stylesheet"
        href="/css/markupHighlight.min.f798cbda9aaa38f89eb38be6414bd082cfd71a6780375cbf67b6d2fb2b96491e.css"
        integrity="sha256-95jL2pqqOPies4vmQUvQgs/XGmeAN1y/Z7bS&#43;yuWSR4="
        crossorigin="anonymous"
        type="text/css">
    
    <link rel="stylesheet" 
    href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css" 
    integrity="sha512-+4zCK9k+qNFUR5X+cKL9EIR+ZOhtIloNl9GIKS57V1MyNsYpYcUrUeQc9vNfzsWfV28IaLL3i96P9sdNyeRssA==" 
    crossorigin="anonymous" />

    
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">

    <link rel="canonical" href="/post/zero_v/">

    
    
    
    
    <script type="text/javascript"
            src="/js/anatole-header.min.0c05c0a90d28c968a1cad4fb31abd0b8e1264e788ccefed022ae1d3b6f627514.js"
            integrity="sha256-DAXAqQ0oyWihytT7MavQuOEmTniMzv7QIq4dO29idRQ="
            crossorigin="anonymous"></script>


    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Zero_v - Cutting Out VTable Calls with the Rust Type System"/>
<meta name="twitter:description" content="A couple of months ago, I was writing an LC3 virtual machine/ emulator that allows users to add their own plugins."/>


    

</head>
<body><div class="sidebar animated fadeInDown ">
    <div class="logo-title">
        <div class="title">
            <img src="/images/profile.jpg" alt="profile picture">
            <h3 title=""><a href="/">Fergal O&#39;Connor</a></h3>
            <div class="description">
                <p>Data Engineer. Rust Enthusiast.<br>Perpetual Tinkerer.</p>
            </div>
        </div>
    </div>
    <ul class="social-links">
        
            <li>
                <a href="https://github.com/fergaljoconnor" rel="me" aria-label="Github">
                    <i class="fab fa-github fa-2x" aria-hidden="true"></i>
                </a>
            </li>
        
            <li>
                <a href="mailto:fergaljamesoconnor@gmail.com" rel="me" aria-label="E-Mail">
                    <i class="fas fa-envelope-square fa-2x" aria-hidden="true"></i>
                </a>
            </li>
        
            <li>
                <a href="https://twitter.com/cachestocrashes" rel="me" aria-label="Twitter">
                    <i class="fab fa-twitter fa-2x" aria-hidden="true"></i>
                </a>
            </li>
        
    </ul>
    <div class="footer">
        <div class="by_farbox">&copy;  Fergal O&#39;Connor 2021 </div>
    </div>
</div>
<div class="main">
    <div class="page-top  animated fadeInDown ">
    <a role="button" class="navbar-burger" data-target="navMenu" aria-label="menu" aria-expanded="false">
        <span aria-hidden="true"></span>
        <span aria-hidden="true"></span>
        <span aria-hidden="true"></span>
    </a>
    <ul class="nav" id="navMenu">
        
        
            
            <li><a 
                   href="/"
                        
                   title="">Home</a></li>
        
            
            <li><a 
                   href="/post/"
                        
                   title="">Posts</a></li>
        
            
            <li><a 
                   href="/about/"
                        
                   title="">About</a></li>
        
        
        
    </ul>
</div>

    <div class="autopagerize_page_element">
        <div class="content">
    <div class="post  animated fadeInDown ">
        <div class="post-content">
            
            <div class="post-title">
                <h3>Zero_v - Cutting Out VTable Calls with the Rust Type System</h3>
                
                    <div class="info">
                        <em class="fas fa-calendar-day"></em>
                        <span class="date"> Sun, May 30, 2021 
                                           </span>
                        <em class="fas fa-stopwatch"></em>
                        <span class="reading-time">15-minute read</span>
                    </div>
                
            </div>

            <p>A couple of months ago, I was writing an LC3 virtual machine/ emulator that allows users to add their own plugins. So a user could write something like:</p>
<div class="highlight"><pre class="chroma"><code class="language-Rust" data-lang="Rust"><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">vm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VM</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span><span class="w"></span><span class="n">vm</span><span class="p">.</span><span class="n">add_plugin</span><span class="p">(</span><span class="n">command_logger</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="n">vm</span><span class="p">.</span><span class="n">add_plugin</span><span class="p">(</span><span class="n">infinite_loop_detector</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="n">vm</span><span class="p">.</span><span class="n">load_program</span><span class="p">(</span><span class="n">my_program</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="n">vm</span><span class="p">.</span><span class="n">run</span><span class="p">()</span><span class="w">
</span></code></pre></div><p>And the VM would call the logger and loop detector whenever a command executed. The way the vm integrated these plugins was simple. There was a plugin trait that defined the interface for a plugin:</p>
<div class="highlight"><pre class="chroma"><code class="language-Rust" data-lang="Rust"><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">Plugin</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">handle_event</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">event</span>: <span class="kp">&amp;</span><span class="nc">Event</span><span class="p">,</span><span class="w"> </span><span class="n">vm</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">VM</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>The VM contained a vector of these plugins and whenever there was an event the vm would report it with:</p>
<div class="highlight"><pre class="chroma"><code class="language-Rust" data-lang="Rust"><span class="k">for</span><span class="w"> </span><span class="n">plugin</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">plugins</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">plugin</span><span class="p">.</span><span class="n">handle_event</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">event</span><span class="p">)</span><span class="o">?</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>There were some complications related to ownership and not modifying the VM while using self.plugins directly (since the plugins are part of the vm, modifying the vm while executing a plugin which is behind a reference to the VM is a bad idea) but we can safely ignore those for now.</p>
<p>This is a natural way to approach the problem and in most cases, the right one. It&rsquo;s straightforward to implement, flexible and makes it easy for the end user to write and add their own plugins.</p>
<p>Unfortunately, it does have a small problem. Inside the VM, the plugins field is defined as:</p>
<div class="highlight"><pre class="chroma"><code class="language-Rust" data-lang="Rust"><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">VM</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// Some fields
</span><span class="c1"></span><span class="w">    </span><span class="n">plugins</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">Plugin</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="c1">// Some more fields
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>We are using trait objects, which means dynamic polymorphism, which means to use a plugin we have to go through a vtable.</p>
<p>And that means vtable overhead.</p>
<p>Most of the time, vtable overhead isn&rsquo;t a big deal. For it to matter you really need to be in a situation where performance is critical, you&rsquo;re counting nanoseconds and you&rsquo;re going to be calling into the vtable a lot. In the case of the VM, performance is important and plugins are called every time the VM sees an event we want to report. Every new command, every memory read or write, every register read or write and every interaction with an IO device will trigger a virtual function call.</p>
<p>So we need to worry about overhead.</p>
<p>This raised the question of whether there was a way for users to inject plugins that:</p>
<ol>
<li>Avoids virtual function calls.</li>
<li>Doesn&rsquo;t require the library user to write much extra boilerplate.</li>
<li>Provides the compiler with as much information about the plugins at compile time as possible.</li>
</ol>
<p>For those upsides, I was prepared to make the following concessions:</p>
<ol>
<li>The user has to specify their plugins at compile time rather than at run time.</li>
<li>The library itself could contain a significant amount of internal boilerplate.</li>
</ol>
<p>This article walks through the solution I came up with, the path I took to get there and some of the tools that helped along the way. Hopefully you&rsquo;ll find some of the ideas interesting or learn something new.</p>
<h1 id="a-simplified-problem-statement">A Simplified Problem Statement</h1>
<p>First, the problem has a bunch of extra details from the VM use case that we don&rsquo;t need. Lets make something simpler.</p>
<div class="highlight"><pre class="chroma"><code class="language-Rust" data-lang="Rust"><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">IntOp</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">run</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">arg</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">usize</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>That&rsquo;s a bit more straightforward. No VM cruft, no events. Just one integer as input and one as output.</p>
<h1 id="designing-a-solution">Designing a Solution</h1>
<p>Instead of treating our collection as a homogenous array of trait objects, we want some way to iterate over function outputs without going through a vtable. One way to do this would be to go through an enum. There&rsquo;s actually a crate that does this, <a href="https://crates.io/crates/enum_dispatch">enum_dispatch.</a> Enum dispatch is great, but it does violate one of our requirements. Lets say a user wants to make their own plugin. Our crate provides an adder they want to use, but they want to add a custom square op. If we use enum_dispatch, then our user has to do something like:</p>
<div class="highlight"><pre class="chroma"><code class="language-Rust" data-lang="Rust"><span class="cp">#[enum_dispatch(Op)]</span><span class="w">
</span><span class="w"></span><span class="k">enum</span> <span class="nc">OpEnum</span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">Adder</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Square</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">ops</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="w">
</span><span class="w">    </span><span class="n">OpEnum</span>::<span class="n">from</span><span class="p">(</span><span class="n">Adder</span>::<span class="n">new</span><span class="p">()),</span><span class="w">
</span><span class="w">    </span><span class="n">OpEnum</span>::<span class="n">from</span><span class="p">(</span><span class="n">Squarer</span>::<span class="n">new</span><span class="p">())</span><span class="w">
</span><span class="w"></span><span class="p">];</span><span class="w">
</span></code></pre></div><p>This is okay, but it&rsquo;s still a chunk of boilerplate. This is also slightly inefficient in terms of memory usage. Every member of our collection is going to be as large as the largest variant of the enum pus the size of the enum tag.</p>
<p>Now, on the other hand, enum dispatch lets collection composition vary at run time and provides a nice interface when you&rsquo;re iterating over the array which is similar to the way you would iterate over trait objects.</p>
<p>Still, lets see if we can find a solution that deals with memory usage and boiler plate.</p>
<p>So the obvious representation of a memory-efficient, tightly packed collection of heterogenous objects is a struct. But in order to have their trait automatically be implemented for a user-defined struct, the intermediate library author would have to write their own procedural macro, which is a lot of heavy lifting.</p>
<p>Lets try something different. What are our options instead of a simple struct?</p>
<p>Well, we want to define a collection which contains one or more heterogenous objects. And we want to be able to define an iterator over this collection. This sounds like a job for generics.</p>
<p>Except for the fact that we won&rsquo;t know how many objects the library user will want in their collection, so we don&rsquo;t know how many objects to be generic over.</p>
<p>One option for this would be to define one type of struct for every number of elements in the struct. So one struct called OneMemberStruct, one called TwoMemberStruct and so on, with the corresponding number of fields over which the types will be generic:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">OneMemberStruct</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">member1</span>: <span class="nc">A</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">TwoMemberStruct</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">member1</span>: <span class="nc">A</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">member2</span>: <span class="nc">B</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>Then we create a trait that defines the behavior of returning an iterator and implement that trait for each struct type. For all collection sizes.</p>
<p>My fingers are starting to hurt just typing that much.</p>
<p>Even with macros, the above solution seems quite ugly. The Rust standard library actually had to do something analogous to this for arrays of different sizes before const generics came along, and while it was workable, it was never ideal. Unfortunately, our collections are heterogenous, so we don&rsquo;t get to use the const generics escape hatch.</p>
<p>So can we create a recursive solution?</p>
<div class="highlight"><pre class="chroma"><code class="language-Rust" data-lang="Rust"><span class="k">struct</span> <span class="nc">MyStruct</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">data</span>: <span class="nc">A</span><span class="w">
</span><span class="w">    </span><span class="n">next</span>: <span class="nc">B</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>If B is another MyStruct, we might have something. It&rsquo;s a little like a linked list. Every node contains some data and the final next field will just be a pointer to the next chunk of data. Except that&rsquo;s not how linked lists work, because the final pointer should be a null. So what does a null look like in Rust? It&rsquo;s usually just an Option. But a None in an option is an object that is null and we want to express a type that is null. The closest thing to this is probably the unit type, ().</p>
<p>So lets take another go at defining our struct. We know we want the next field to either be a MyStruct or the unit type. And we&rsquo;ll change the type name to reflect the linked list idea.</p>
<div class="highlight"><pre class="chroma"><code class="language-Rust" data-lang="Rust"><span class="k">struct</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span>: <span class="nc">NextNode</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">data</span>: <span class="nc">A</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">next</span>: <span class="nc">B</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">trait</span><span class="w"> </span><span class="n">NextNode</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">NextNode</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">()</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span>:<span class="nc">NextNode</span><span class="o">&gt;</span><span class="w"> </span><span class="n">NextNode</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">MyStruct</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></code></pre></div><p>But what does an empty collection look like? We could use the unit type as the empty collection, but implementing more behavior than we have to for the unit type seems like a bad idea.</p>
<p>Instead, lets have a simple type representing the entry point to the collection for the user.</p>
<div class="highlight"><pre class="chroma"><code class="language-Rust" data-lang="Rust"><span class="k">struct</span> <span class="nc">Composite</span><span class="o">&lt;</span><span class="n">A</span>: <span class="nc">NextNode</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">head</span>: <span class="nc">A</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>Great, we have a type. Lets imagine we have some constructors defined too (omitted here, the new() functions will most likely look like what you expect) But what does client code look like right now?</p>
<div class="highlight"><pre class="chroma"><code class="language-Rust" data-lang="Rust"><span class="kd">let</span><span class="w"> </span><span class="n">collection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Composite</span>::<span class="n">new</span><span class="p">(</span><span class="w">
</span><span class="w">        </span><span class="n">Node</span>:::<span class="n">new</span><span class="p">(</span><span class="n">object1</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">Node</span>::<span class="n">new</span><span class="p">(</span><span class="n">object2</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">Node</span>::<span class="n">new</span><span class="p">(</span><span class="n">object3</span><span class="p">,</span><span class="w"> </span><span class="p">())</span><span class="w">
</span><span class="w">        </span><span class="p">))</span><span class="w">
</span><span class="w">    </span><span class="p">);</span><span class="w">
</span></code></pre></div><p>Ugh. Lets not do that.</p>
<p>So, we have a collection where there can be an arbitrary amount of objects of different types fed to the constructor. This looks like a job for macros.</p>
<p>First we want a macro that will look something like:</p>
<div class="highlight"><pre class="chroma"><code class="language-Rust" data-lang="Rust"><span class="kd">let</span><span class="w"> </span><span class="n">nodes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">compose_nodes</span><span class="o">!</span><span class="p">(</span><span class="n">object1</span><span class="p">,</span><span class="w"> </span><span class="n">object2</span><span class="p">,</span><span class="w"> </span><span class="n">object3</span><span class="p">);</span><span class="w">
</span></code></pre></div><p>Which will give us our nodes without the user having to worry about the nested calls to the node constructor.</p>
<div class="highlight"><pre class="chroma"><code class="language-Rust" data-lang="Rust"><span class="n">macro_rules</span><span class="o">!</span><span class="w"> </span><span class="n">compose_nodes</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="p">()</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="p">()</span><span class="w">
</span><span class="w">    </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="p">(</span><span class="cp">$val</span>: <span class="nc">expr</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">       </span><span class="n">Node</span>::<span class="n">base</span><span class="p">(</span><span class="cp">$val</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="p">(</span><span class="cp">$left</span>: <span class="nc">expr</span><span class="p">,</span><span class="w"> </span><span class="cp">$($right</span>: <span class="nc">expr</span><span class="p">),</span><span class="w"> </span><span class="o">+</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Node</span>::<span class="n">new</span><span class="p">(</span><span class="cp">$left</span><span class="p">,</span><span class="w"> </span><span class="n">compose_nodes</span><span class="o">!</span><span class="p">(</span><span class="w"> </span><span class="cp">$($right</span><span class="p">),</span><span class="w"> </span><span class="o">+</span><span class="p">))</span><span class="w">
</span><span class="w">    </span><span class="p">};</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>This is simple enough. If it&rsquo;s empty, return the unit type. If it&rsquo;s a single value, return a node with that value as the data field and the unit type as the next field (this is all Node::base does) and finally, if it&rsquo;s two or more values, return a node with the first value in the data field and the macro result of the remaining values in the next field.</p>
<p>Let&rsquo;s add a simpler helper macro to put a Composite::new call on top of that.</p>
<div class="highlight"><pre class="chroma"><code class="language-Rust" data-lang="Rust"><span class="n">macro_rules</span><span class="o">!</span><span class="w"> </span><span class="n">compose</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="p">(</span><span class="cp">$($right</span>: <span class="nc">expr</span><span class="p">),</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Composite</span>::<span class="n">new</span><span class="p">(</span><span class="n">compose_nodes</span><span class="o">!</span><span class="p">(</span><span class="w"> </span><span class="cp">$($right</span><span class="p">),</span><span class="w"> </span><span class="o">*</span><span class="p">))</span><span class="w">
</span><span class="w">    </span><span class="p">};</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>And that gives the end-user a pretty interface when they&rsquo;re defining their collection:</p>
<div class="highlight"><pre class="chroma"><code class="language-Rust" data-lang="Rust"><span class="kd">let</span><span class="w"> </span><span class="n">composite</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">compose</span><span class="o">!</span><span class="p">(</span><span class="w">
</span><span class="w">    </span><span class="n">ObjectType1</span>::<span class="n">new</span><span class="p">(),</span><span class="w">
</span><span class="w">    </span><span class="n">ObjectType2</span>::<span class="n">new</span><span class="p">(),</span><span class="w">
</span><span class="w">    </span><span class="n">ObjectType3</span>::<span class="n">new</span><span class="p">()</span><span class="w">
</span><span class="w"></span><span class="p">);</span><span class="w">
</span></code></pre></div><h1 id="defining-iteration-over-this-collection">Defining Iteration Over This Collection</h1>
<p>Great. That&rsquo;s one problem sorted. But now how does a library writer define the behavior they want over a collection.</p>
<p>This is where the tradeoff with the enum solution comes back to bite us. If the collection was composed of enums, you could iterate over it in a pretty standard way, by returning an iterator over &amp;EnumType. All our objects can be of different types, so that&rsquo;s not an option. We could iterate over &amp;dyn TraitType, but then, even though we keep the compact memory representation of the composite solution, we are back to virtual functions and pointer chasing.</p>
<p>So is there a way we can have our cake and eat it too?</p>
<p>Sort of. Lets look at the definition of our trait again.</p>
<div class="highlight"><pre class="chroma"><code class="language-Rust" data-lang="Rust"><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">IntOp</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">run</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">arg</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">usize</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>We can&rsquo;t iterate over a collection of these, because they might all have different types. But we do have one escape hatch. The return type of the function is always going to be the same, so what if we set that to our iterator return type?</p>
<div class="highlight"><pre class="chroma"><code class="language-Rust" data-lang="Rust"><span class="k">struct</span> <span class="nc">CompositeIterator</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="n">Nodes</span>: <span class="nc">NextNode</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">nodes</span>: <span class="kp">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="n">Nodes</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">index</span>: <span class="kt">usize</span>
<span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="n">Nodes</span>: <span class="nc">NextNode</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Iterator</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">CompositeIterator</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="n">Nodes</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">usize</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="c1">// We&#39;ll get back to this implementation later.
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>A major problem with this implementation as it stands is that there&rsquo;s no guarantee that members of the collection implement IntOp. So we&rsquo;ll need a marker trait that can prove they do.</p>
<div class="highlight"><pre class="chroma"><code class="language-Rust" data-lang="Rust"><span class="k">trait</span><span class="w"> </span><span class="n">IntOpCollection</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">A</span>: <span class="nc">IntOp</span><span class="p">,</span><span class="w"> </span><span class="n">B</span>: <span class="nc">IntOpCollection</span><span class="o">&gt;</span><span class="w"> </span><span class="n">IntOpCollection</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Node</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">IntOpCollection</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></code></pre></div><p>Now we can change the bounds on our CompositeIterator to:</p>
<div class="highlight"><pre class="chroma"><code class="language-Rust" data-lang="Rust"><span class="k">struct</span> <span class="nc">CompositeIterator</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="n">Nodes</span>: <span class="nc">NextNode</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">IntOpCollection</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">//...
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>That means we know our collection contains ony objects implementing our trait. But how do we iterate over it?</p>
<p>Well, our iterator will keep an index that we&rsquo;ll incremement between iterations. So we just need a way to get the output of the run function for the element at that index.</p>
<p>But the curse of heterogenous collections strikes again. We can&rsquo;t index into the collection, because the return type of the index operation could be any of the types in our collection.</p>
<p>Maybe we can use the recursive nature of IntOpCollection to do something?</p>
<div class="highlight"><pre class="chroma"><code class="language-Rust" data-lang="Rust"><span class="k">trait</span><span class="w"> </span><span class="n">IntOpCollection</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">run_at_index</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">arg</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">index</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">A</span>: <span class="nc">IntOp</span><span class="p">,</span><span class="w"> </span><span class="n">B</span>: <span class="nc">IntOpCollection</span><span class="o">&gt;</span><span class="w"> </span><span class="n">IntOpCollection</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Node</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">run_at_index</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">arg</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">index</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="nb">Some</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">arg</span><span class="p">))</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">next</span><span class="p">.</span><span class="n">run_at_index</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">IntOpCollection</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">run_at_index</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">arg</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">index</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="nb">None</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>The real action here happens in the implementation for a Node. If the index has reached zero, we return the result of running the operation at the head of that collection. Otherwise we decrement the index and pass it to the run_at_index method for the subcollection in the next node. Eventually, when the starting index gets big enough, it will reach the unit type at the end of the collection before the index hits zero and return None, which is exactly what we want.</p>
<p>That gives us the behavior we want. Back to our iterator.</p>
<p>The iterator needs to keep track of the index, hold a reference to the collection and feeds the input arguments to the right element of the collection on each iteration.</p>
<div class="highlight"><pre class="chroma"><code class="language-Rust" data-lang="Rust"><span class="k">struct</span> <span class="nc">CompositeIterator</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="n">Nodes</span>: <span class="nc">NextNode</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">nodes</span>: <span class="kp">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="n">Nodes</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">index</span>: <span class="kt">usize</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">arg</span>: <span class="kt">usize</span>
<span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="n">Nodes</span>: <span class="nc">NextNode</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Iterator</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">CompositeIterator</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="n">Nodes</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">usize</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">nodes</span><span class="p">.</span><span class="n">run_at_index</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">index</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">index</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="n">output</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>This gives us something like a reverse of the map function on a collection. Map takes a single function and runs it using each item of the collection as an input. Here we take a single input, and run each function in the collection on it. Well, you could also think of this as using map over a collection of functions where the function passed to map is a closure that calls the function on the single input. Either way, this is only one of the things you might want to do with a collection. For example, what if we wanted to pass the output of one function to the input of the next for an accumulator?</p>
<p>This can be done, as long as we can set the value of the input field, by doing something like:</p>
<div class="highlight"><pre class="chroma"><code class="language-Rust" data-lang="Rust"><span class="kd">let</span><span class="w"> </span><span class="n">last_output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">input</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">while</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">output</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">composite_iterator</span><span class="p">.</span><span class="n">next</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">composite_iterator</span><span class="p">.</span><span class="n">arg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">output</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="n">last_output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">output</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">};</span><span class="w">
</span></code></pre></div><p>Changing the input field mid-iteration should let us get all the behavior we&rsquo;ll need from the iterator.</p>
<p>So that&rsquo;s it for the implementation. It took fifty lines of boilerplate, but we got there. Let&rsquo;s look at all of that together.</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">IntOp</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">execute</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">input</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">usize</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">trait</span><span class="w"> </span><span class="n">IntOpAtLevel</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">execute_at_level</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">input</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">level</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">A</span>: <span class="nc">IntOp</span><span class="p">,</span><span class="w"> </span><span class="n">B</span>: <span class="nc">NextNode</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">IntOpAtLevel</span><span class="o">&gt;</span><span class="w"> </span><span class="n">IntOpAtLevel</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Node</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">execute_at_level</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">input</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">level</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">level</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="nb">Some</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">execute</span><span class="p">(</span><span class="n">input</span><span class="p">))</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">next</span><span class="p">.</span><span class="n">execute_at_level</span><span class="p">(</span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="n">level</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">IntOpAtLevel</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">execute_at_level</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">_input</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">_level</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="nb">None</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">CompositeIterator</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="n">Nodes</span>: <span class="nc">NextNode</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">IntOpAtLevel</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">level</span>: <span class="kt">usize</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">input</span>: <span class="kt">usize</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">parent</span>: <span class="kp">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="n">Nodes</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="n">Nodes</span>: <span class="nc">NextNode</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">IntOpAtLevel</span><span class="o">&gt;</span><span class="w"> </span><span class="n">CompositeIterator</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="n">Nodes</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">parent</span>: <span class="kp">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="n">Nodes</span><span class="p">,</span><span class="w"> </span><span class="n">input</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">parent</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">input</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">level</span>: <span class="mi">0</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="n">Nodes</span>: <span class="nc">NextNode</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">IntOpAtLevel</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Iterator</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">CompositeIterator</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="n">Nodes</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">usize</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">parent</span><span class="p">.</span><span class="n">execute_at_level</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">level</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">level</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="n">result</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">trait</span><span class="w"> </span><span class="n">IterExecute</span><span class="o">&lt;</span><span class="n">Nodes</span>: <span class="nc">NextNode</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">IntOpAtLevel</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">   </span><span class="k">fn</span> <span class="nf">iter_execute</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">input</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">CompositeIterator</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="p">,</span><span class="w"> </span><span class="n">Nodes</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">Nodes</span>: <span class="nc">NextNode</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">IntOpAtLevel</span><span class="o">&gt;</span><span class="w"> </span><span class="n">IterExecute</span><span class="o">&lt;</span><span class="n">Nodes</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Composite</span><span class="o">&lt;</span><span class="n">Nodes</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">   </span><span class="k">fn</span> <span class="nf">iter_execute</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">input</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">CompositeIterator</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="p">,</span><span class="w"> </span><span class="n">Nodes</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">       </span><span class="n">CompositeIterator</span>::<span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">head</span><span class="p">,</span><span class="w"> </span><span class="n">input</span><span class="p">)</span><span class="w">
</span><span class="w">   </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h1 id="performance-tuning">Performance Tuning</h1>
<p>The above works, but is it actually giving the expected speedups? After all, if
it isn&rsquo;t then users are jumping through a series of boilerplate hoops for
nothing. We need to justify their effort.</p>
<p>Before I get into the becnhmarks, a few quick caveats.</p>
<ul>
<li>Performance varies between different hardware setups. If you care about
performance enough to try something like this, please test on your own
production setup to make sure these figures reflect your experience.</li>
<li>I saw some odd behaviour when running these benchmarks. Basically, changing
the way functions were inlined for the static solution seemed to affect times
for the dynamic solution while the two should be independent. At first I
assumed it was due to the laptop throttling the CPU if the static run was fast
enough, and the dynamic benches after it being hit by the throttling as a
result. But swapping the order of the benchmarks made no difference, which
would have been the case if throttling was the issue. For now I&rsquo;m putting it
down to either some compiler oddity or something in the benchmark framework
itself and given the performance I saw, I do believe this solution
absolutely smokes the dynamic solution in terms of speed.</li>
</ul>
<p>The benchmarks are divided into four groups, two groups using dynamic calls
and two using static calls. Within each of these sets, one benchmark uses
an object with the parameter embedded in the object and one uses a small
extra tweak where the parameter is baked in at compile time using const
generics.</p>
<p>Basically, you&rsquo;re looking at something like this in the parameter case:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">Adder</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">value</span>: <span class="kt">usize</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Adder</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">value</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">IntOp</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Adder</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">execute</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">input</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">usize</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">input</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">value</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>And in the const case, an operation will look like this:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">ConstAdder</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">VALUE</span>: <span class="kt">usize</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">VALUE</span>: <span class="kt">usize</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ConstAdder</span><span class="o">&lt;</span><span class="n">VALUE</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">new</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">VALUE</span>: <span class="kt">usize</span><span class="o">&gt;</span><span class="w"> </span><span class="n">IntOp</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">ConstAdder</span><span class="o">&lt;</span><span class="n">VALUE</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">execute</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">input</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">usize</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">input</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">VALUE</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>In addition, there was one baseline benchmark that takes the sledgehammer
apparoach, by pushing all the operations into a single function with
no other abstractions. Spoilers, this one crushes both the virtual and static
benchmarks in terms of performance, and it is not close. If you really need
the performance, sometimes it pays to be nice to your compiler.</p>
<p>Oh, and the main code for the benchmarks is included in the footnotes<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>.
That&rsquo;s all the legalese taken care of. Onto the results.</p>
<p><img src="/images/violin_no_inline.jpg" alt="Benchmark Results with No Inlining"></p>
<p>I wasn&rsquo;t joking when I said the baseline crushes the other two methods.
It beats the parameter-based vtable run by a couple of orders of magnitude,
clocking in at just over a nanosecond per iteration.</p>
<p>Looking at the static versus dynamic results though, we&rsquo;ve got a pretty
clear victory for the static dispatch benchmarks, clocking in at around 3 times
as fast as dynamic dispatch, which seems like a pretty clear vindication of the
effort involved. Assuming you really need those cycles.</p>
<p>So, can we make it any faster?</p>
<p>Sure. I&rsquo;ll save you the results of the benchmarks for the experiments along the
way (imagine doing the hokey pokey, but with inline function annotations)
and get straight to the optimizations that worked. Basically, the best run
involved adding inline annotations to three methods.</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="w"> </span><span class="n">IntOpAtLevel</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="cp">#[inline]</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">execute_at_level</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">_input</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">_level</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="nb">None</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">A</span>: <span class="nc">IntOp</span><span class="p">,</span><span class="w"> </span><span class="n">B</span>: <span class="nc">NextNode</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">IntOpAtLevel</span><span class="o">&gt;</span><span class="w"> </span><span class="n">IntOpAtLevel</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Node</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="cp">#[inline]</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">execute_at_level</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">input</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">level</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">level</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">next</span><span class="p">.</span><span class="n">execute_at_level</span><span class="p">(</span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="n">level</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="nb">Some</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">execute</span><span class="p">(</span><span class="n">input</span><span class="p">))</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="n">Nodes</span>: <span class="nc">NextNode</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">IntOpAtLevel</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Iterator</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">CompositeIterator</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="n">Nodes</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">usize</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="cp">#[inline]</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">parent</span><span class="p">.</span><span class="n">execute_at_level</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">level</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">level</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="n">result</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>Which resulted in the following changes to the benchmarks:</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">Integer Ops/Static/Arg  time:   [25.491 ns 25.611 ns 25.761 ns]                                    
                        change: [-19.267% -18.424% -17.520%] (p = 0.00 &lt; 0.05)
                        Performance has improved.
Found 10 outliers among 100 measurements (10.00%)
  3 (3.00%) high mild
  7 (7.00%) high severe
Integer Ops/Vtable/Arg  time:   [109.78 ns 110.13 ns 110.60 ns]                                   
                        change: [-7.5058% -7.2445% -6.9897%] (p = 0.00 &lt; 0.05)
                        Performance has improved.
Found 13 outliers among 100 measurements (13.00%)
  7 (7.00%) high mild
  6 (6.00%) high severe
Integer Ops/Static/Const                                                                             
                        time:   [21.950 ns 21.978 ns 22.011 ns]
                        change: [-37.411% -36.599% -35.701%] (p = 0.00 &lt; 0.05)
                        Performance has improved.
Found 10 outliers among 100 measurements (10.00%)
  3 (3.00%) high mild
  7 (7.00%) high severe
Integer Ops/Vtable/Const                                                                            
                        time:   [102.87 ns 103.12 ns 103.48 ns]
                        change: [+12.436% +12.884% +13.492%] (p = 0.00 &lt; 0.05)
                        Performance has regressed.
Found 15 outliers among 100 measurements (15.00%)
  9 (9.00%) high mild
  6 (6.00%) high severe
Integer Ops/Baseline    time:   [1.1747 ns 1.1758 ns 1.1771 ns]                                  
                        change: [-0.3156% -0.0230% +0.3152%] (p = 0.90 &gt; 0.05)
                        No change in performance detected.
Found 7 outliers among 100 measurements (7.00%)
  1 (1.00%) high mild
  6 (6.00%) high severe

</code></pre></div><p>So, first off, I want to stress again that something weird is going on here.
Those vtable benchmarks shouldn&rsquo;t be affected by the changes I made to the
static benchmarks. However, even with that oddness, it&rsquo;s clear that those
inline annotations have bought us another 20% in performance for very little
effort (the set of functions was small enough that I could skip going through
profiling and head straight to the step where I spend a few minutes dropping
inline annotations on functions and seeing what the numbers tell me).</p>
<h1 id="conclusion">Conclusion</h1>
<p>So it looks like we&rsquo;ve achieved everything we set out to accomplish. The crate
is small and simple. It does involve a decent bit of boilerplate on the part of
the intermediate library author, but once that&rsquo;s in place, their users only
ever need to create a collection with the compose macro, which is exactly what
we had in mind. And our benchmarks confirm we&rsquo;re getting the expected
performance jump compared to dynamic allocation.</p>
<p>I&rsquo;ve <a href="https://crates.io/crates/zero_v">published the code on crates</a> in case
anyone finds it useful. Thanks for reading, and feel free to contact me with
any questions.</p>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>Benchmarks Code. <a href="https://github.com/fergaljoconnor/zero_v/blob/main/benches/integer_ops.rs">Full Source On Github</a></p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">bench_composed</span><span class="o">&lt;</span><span class="n">NodeType</span><span class="p">,</span><span class="w"> </span><span class="n">Composed</span><span class="o">&gt;</span><span class="p">(</span><span class="n">input</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">composed</span>: <span class="kp">&amp;</span><span class="nc">Composed</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">usize</span>
<span class="nc">where</span><span class="w">
</span><span class="w">    </span><span class="n">NodeType</span>: <span class="nc">IntOpAtLevel</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">NextNode</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Composed</span>: <span class="nc">IterIntOps</span><span class="o">&lt;</span><span class="n">NodeType</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">composed</span><span class="p">.</span><span class="n">iter_execute</span><span class="p">(</span><span class="n">input</span><span class="p">).</span><span class="n">sum</span><span class="p">()</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">    
</span><span class="w"></span><span class="k">fn</span> <span class="nf">bench_trait_objects</span><span class="p">(</span><span class="n">input</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">ops</span>: <span class="kp">&amp;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">IntOp</span><span class="o">&gt;&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">usize</span> <span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">ops</span><span class="p">.</span><span class="n">iter</span><span class="p">().</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">op</span><span class="o">|</span><span class="w"> </span><span class="n">op</span><span class="p">.</span><span class="n">execute</span><span class="p">(</span><span class="n">input</span><span class="p">)).</span><span class="n">sum</span><span class="p">()</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">    
</span><span class="w"></span><span class="k">fn</span> <span class="nf">bench_baseline</span><span class="p">(</span><span class="n">input</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">usize</span> <span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="p">(</span><span class="n">input</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">input</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">input</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">input</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">input</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">input</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">input</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">6</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">input</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">7</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">input</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">input</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">9</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">input</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">input</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">11</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">input</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">12</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">input</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">13</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">    
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">criterion_benchmark</span><span class="p">(</span><span class="n">c</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Criterion</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">group</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="p">.</span><span class="n">benchmark_group</span><span class="p">(</span><span class="s">&#34;Integer Ops&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">    
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">ops_dyn</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">IntOp</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="w">
</span><span class="w">        </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">Adder</span>::<span class="n">new</span><span class="p">(</span><span class="mi">0</span><span class="p">)),</span><span class="w">
</span><span class="w">        </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">LShifter</span>::<span class="n">new</span><span class="p">(</span><span class="mi">1</span><span class="p">)),</span><span class="w">
</span><span class="w">        </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">Adder</span>::<span class="n">new</span><span class="p">(</span><span class="mi">2</span><span class="p">)),</span><span class="w">
</span><span class="w">        </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">Multiplier</span>::<span class="n">new</span><span class="p">(</span><span class="mi">3</span><span class="p">)),</span><span class="w">
</span><span class="w">        </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">Adder</span>::<span class="n">new</span><span class="p">(</span><span class="mi">4</span><span class="p">)),</span><span class="w">
</span><span class="w">        </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">Multiplier</span>::<span class="n">new</span><span class="p">(</span><span class="mi">5</span><span class="p">)),</span><span class="w">
</span><span class="w">        </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">Adder</span>::<span class="n">new</span><span class="p">(</span><span class="mi">6</span><span class="p">)),</span><span class="w">
</span><span class="w">        </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">Multiplier</span>::<span class="n">new</span><span class="p">(</span><span class="mi">7</span><span class="p">)),</span><span class="w">
</span><span class="w">        </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">Adder</span>::<span class="n">new</span><span class="p">(</span><span class="mi">8</span><span class="p">)),</span><span class="w">
</span><span class="w">        </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">Multiplier</span>::<span class="n">new</span><span class="p">(</span><span class="mi">9</span><span class="p">)),</span><span class="w">
</span><span class="w">        </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">Adder</span>::<span class="n">new</span><span class="p">(</span><span class="mi">10</span><span class="p">)),</span><span class="w">
</span><span class="w">        </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">RShifter</span>::<span class="n">new</span><span class="p">(</span><span class="mi">11</span><span class="p">)),</span><span class="w">
</span><span class="w">        </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">Adder</span>::<span class="n">new</span><span class="p">(</span><span class="mi">12</span><span class="p">)),</span><span class="w">
</span><span class="w">        </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">RShifter</span>::<span class="n">new</span><span class="p">(</span><span class="mi">13</span><span class="p">)),</span><span class="w">
</span><span class="w">    </span><span class="p">];</span><span class="w">
</span><span class="w">    
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">ops_dyn_const</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">IntOp</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="w">
</span><span class="w">        </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">ConstAdder</span>::<span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span>::<span class="n">new</span><span class="p">()),</span><span class="w">
</span><span class="w">        </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">ConstLShifter</span>::<span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span>::<span class="n">new</span><span class="p">()),</span><span class="w">
</span><span class="w">        </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">ConstAdder</span>::<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span>::<span class="n">new</span><span class="p">()),</span><span class="w">
</span><span class="w">        </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">ConstMultiplier</span>::<span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span>::<span class="n">new</span><span class="p">()),</span><span class="w">
</span><span class="w">        </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">ConstAdder</span>::<span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span>::<span class="n">new</span><span class="p">()),</span><span class="w">
</span><span class="w">        </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">ConstMultiplier</span>::<span class="o">&lt;</span><span class="mi">5</span><span class="o">&gt;</span>::<span class="n">new</span><span class="p">()),</span><span class="w">
</span><span class="w">        </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">ConstAdder</span>::<span class="o">&lt;</span><span class="mi">6</span><span class="o">&gt;</span>::<span class="n">new</span><span class="p">()),</span><span class="w">
</span><span class="w">        </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">ConstMultiplier</span>::<span class="o">&lt;</span><span class="mi">7</span><span class="o">&gt;</span>::<span class="n">new</span><span class="p">()),</span><span class="w">
</span><span class="w">        </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">ConstAdder</span>::<span class="o">&lt;</span><span class="mi">8</span><span class="o">&gt;</span>::<span class="n">new</span><span class="p">()),</span><span class="w">
</span><span class="w">        </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">ConstMultiplier</span>::<span class="o">&lt;</span><span class="mi">9</span><span class="o">&gt;</span>::<span class="n">new</span><span class="p">()),</span><span class="w">
</span><span class="w">        </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">ConstAdder</span>::<span class="o">&lt;</span><span class="mi">10</span><span class="o">&gt;</span>::<span class="n">new</span><span class="p">()),</span><span class="w">
</span><span class="w">        </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">ConstRShifter</span>::<span class="o">&lt;</span><span class="mi">11</span><span class="o">&gt;</span>::<span class="n">new</span><span class="p">()),</span><span class="w">
</span><span class="w">        </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">ConstAdder</span>::<span class="o">&lt;</span><span class="mi">12</span><span class="o">&gt;</span>::<span class="n">new</span><span class="p">()),</span><span class="w">
</span><span class="w">        </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">ConstRShifter</span>::<span class="o">&lt;</span><span class="mi">13</span><span class="o">&gt;</span>::<span class="n">new</span><span class="p">()),</span><span class="w">
</span><span class="w">    </span><span class="p">];</span><span class="w">
</span><span class="w">    
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">ops</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">compose</span><span class="o">!</span><span class="p">(</span><span class="w">
</span><span class="w">        </span><span class="n">Adder</span>::<span class="n">new</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="n">LShifter</span>::<span class="n">new</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="n">Adder</span>::<span class="n">new</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="n">Multiplier</span>::<span class="n">new</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="n">Adder</span>::<span class="n">new</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="n">Multiplier</span>::<span class="n">new</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="n">Adder</span>::<span class="n">new</span><span class="p">(</span><span class="mi">6</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="n">Multiplier</span>::<span class="n">new</span><span class="p">(</span><span class="mi">7</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="n">Adder</span>::<span class="n">new</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="n">Multiplier</span>::<span class="n">new</span><span class="p">(</span><span class="mi">9</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="n">Adder</span>::<span class="n">new</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="n">RShifter</span>::<span class="n">new</span><span class="p">(</span><span class="mi">11</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="n">Adder</span>::<span class="n">new</span><span class="p">(</span><span class="mi">12</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="n">RShifter</span>::<span class="n">new</span><span class="p">(</span><span class="mi">13</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">);</span><span class="w">
</span><span class="w">    
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">ops_const</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">compose</span><span class="o">!</span><span class="p">(</span><span class="w">
</span><span class="w">        </span><span class="n">ConstAdder</span>::<span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span>::<span class="n">new</span><span class="p">(),</span><span class="w">
</span><span class="w">        </span><span class="n">ConstLShifter</span>::<span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span>::<span class="n">new</span><span class="p">(),</span><span class="w">
</span><span class="w">        </span><span class="n">ConstAdder</span>::<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span>::<span class="n">new</span><span class="p">(),</span><span class="w">
</span><span class="w">        </span><span class="n">ConstMultiplier</span>::<span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span>::<span class="n">new</span><span class="p">(),</span><span class="w">
</span><span class="w">        </span><span class="n">ConstAdder</span>::<span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span>::<span class="n">new</span><span class="p">(),</span><span class="w">
</span><span class="w">        </span><span class="n">ConstMultiplier</span>::<span class="o">&lt;</span><span class="mi">5</span><span class="o">&gt;</span>::<span class="n">new</span><span class="p">(),</span><span class="w">
</span><span class="w">        </span><span class="n">ConstAdder</span>::<span class="o">&lt;</span><span class="mi">6</span><span class="o">&gt;</span>::<span class="n">new</span><span class="p">(),</span><span class="w">
</span><span class="w">        </span><span class="n">ConstMultiplier</span>::<span class="o">&lt;</span><span class="mi">7</span><span class="o">&gt;</span>::<span class="n">new</span><span class="p">(),</span><span class="w">
</span><span class="w">        </span><span class="n">ConstAdder</span>::<span class="o">&lt;</span><span class="mi">8</span><span class="o">&gt;</span>::<span class="n">new</span><span class="p">(),</span><span class="w">
</span><span class="w">        </span><span class="n">ConstMultiplier</span>::<span class="o">&lt;</span><span class="mi">9</span><span class="o">&gt;</span>::<span class="n">new</span><span class="p">(),</span><span class="w">
</span><span class="w">        </span><span class="n">ConstAdder</span>::<span class="o">&lt;</span><span class="mi">10</span><span class="o">&gt;</span>::<span class="n">new</span><span class="p">(),</span><span class="w">
</span><span class="w">        </span><span class="n">ConstRShifter</span>::<span class="o">&lt;</span><span class="mi">11</span><span class="o">&gt;</span>::<span class="n">new</span><span class="p">(),</span><span class="w">
</span><span class="w">        </span><span class="n">ConstAdder</span>::<span class="o">&lt;</span><span class="mi">12</span><span class="o">&gt;</span>::<span class="n">new</span><span class="p">(),</span><span class="w">
</span><span class="w">        </span><span class="n">ConstRShifter</span>::<span class="o">&lt;</span><span class="mi">13</span><span class="o">&gt;</span>::<span class="n">new</span><span class="p">()</span><span class="w">
</span><span class="w">    </span><span class="p">);</span><span class="w">
</span><span class="w">    
</span><span class="w">    </span><span class="n">group</span><span class="p">.</span><span class="n">bench_function</span><span class="p">(</span><span class="s">&#34;Static/Arg&#34;</span><span class="p">,</span><span class="w"> </span><span class="o">|</span><span class="n">b</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">b</span><span class="p">.</span><span class="n">iter</span><span class="p">(</span><span class="o">||</span><span class="w"> </span><span class="n">bench_composed</span><span class="p">(</span><span class="n">black_box</span><span class="p">(</span><span class="mi">20</span><span class="p">),</span><span class="w"> </span><span class="n">black_box</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ops</span><span class="p">)))</span><span class="w">
</span><span class="w">    </span><span class="p">});</span><span class="w">
</span><span class="w">    
</span><span class="w">    </span><span class="n">group</span><span class="p">.</span><span class="n">bench_function</span><span class="p">(</span><span class="s">&#34;Vtable/Arg&#34;</span><span class="p">,</span><span class="w"> </span><span class="o">|</span><span class="n">b</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">b</span><span class="p">.</span><span class="n">iter</span><span class="p">(</span><span class="o">||</span><span class="w"> </span><span class="n">bench_trait_objects</span><span class="p">(</span><span class="n">black_box</span><span class="p">(</span><span class="mi">20</span><span class="p">),</span><span class="w"> </span><span class="n">black_box</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ops_dyn</span><span class="p">)))</span><span class="w">
</span><span class="w">    </span><span class="p">});</span><span class="w">
</span><span class="w">    
</span><span class="w">    </span><span class="n">group</span><span class="p">.</span><span class="n">bench_function</span><span class="p">(</span><span class="s">&#34;Static/Const&#34;</span><span class="p">,</span><span class="w"> </span><span class="o">|</span><span class="n">b</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">b</span><span class="p">.</span><span class="n">iter</span><span class="p">(</span><span class="o">||</span><span class="w"> </span><span class="n">bench_composed</span><span class="p">(</span><span class="n">black_box</span><span class="p">(</span><span class="mi">20</span><span class="p">),</span><span class="w"> </span><span class="n">black_box</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ops_const</span><span class="p">)))</span><span class="w">
</span><span class="w">    </span><span class="p">});</span><span class="w">
</span><span class="w">    
</span><span class="w">    </span><span class="n">group</span><span class="p">.</span><span class="n">bench_function</span><span class="p">(</span><span class="s">&#34;Vtable/Const&#34;</span><span class="p">,</span><span class="w"> </span><span class="o">|</span><span class="n">b</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">b</span><span class="p">.</span><span class="n">iter</span><span class="p">(</span><span class="o">||</span><span class="w"> </span><span class="n">bench_trait_objects</span><span class="p">(</span><span class="n">black_box</span><span class="p">(</span><span class="mi">20</span><span class="p">),</span><span class="w"> </span><span class="n">black_box</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ops_dyn_const</span><span class="p">)))</span><span class="w">
</span><span class="w">    </span><span class="p">});</span><span class="w">
</span><span class="w">    
</span><span class="w">    </span><span class="n">group</span><span class="p">.</span><span class="n">bench_function</span><span class="p">(</span><span class="s">&#34;Baseline&#34;</span><span class="p">,</span><span class="w"> </span><span class="o">|</span><span class="n">b</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">b</span><span class="p">.</span><span class="n">iter</span><span class="p">(</span><span class="o">||</span><span class="w"> </span><span class="n">bench_baseline</span><span class="p">(</span><span class="n">black_box</span><span class="p">(</span><span class="mi">20</span><span class="p">)))</span><span class="w">
</span><span class="w">    </span><span class="p">});</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">    
</span><span class="w"></span><span class="n">criterion_group</span><span class="o">!</span><span class="p">(</span><span class="n">benches</span><span class="p">,</span><span class="w"> </span><span class="n">criterion_benchmark</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="n">criterion_main</span><span class="o">!</span><span class="p">(</span><span class="n">benches</span><span class="p">);</span><span class="w">
</span></code></pre></div>&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></li>
</ol>
</section>
</div>
        <div class="post-footer">
            <div class="info">
                
                
            </div>
        </div>

        
    </div>


        </div>
    </div>
</div>

<script type="text/javascript"
        src="/js/medium-zoom.min.83cb1dd5fea8d42d87d1e601a07faa73089ad0ef9ccfe5daf6041289ebcc4e46.js"
        integrity="sha256-g8sd1f6o1C2H0eYBoH&#43;qcwia0O&#43;cz&#43;Xa9gQSievMTkY="
        crossorigin="anonymous"></script></body>

</html>
